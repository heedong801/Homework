기본적으로 특정 메모리 영역을 Hash
숫자로 변환하는 것을 말합니다.

// 10바이트
"aaaccccddd" 0b00000000000000000100000000000100;
             1
// 다르죠?
"fasdfasde"  0b00000000000000000000100000001000;
             0

겹치지 않으니까 다르다고 볼수 있고 그걸 기반으로
// 기본적으로 배열안에 이 2개의 자료를 구분해서 넣을수 있다.
["fasdfasde"]["aaaccccddd"][][][][][][]

해쉬를 착각하는게 암호화와 비교합니다.

암호화 => "Hello" = 암호화 => "hhhhee" = 복호화 => "Hello"

해  쉬 => "Hello" = 해쉬 => 2 

int HashValue = 남들이 만든 해쉬(내가 넣고 싶은값)
int HashValue = 내가 만든 해쉬(내가 넣고 싶은값)

// hashtable unordered_map

0 = 해쉬함수("fasdfasde");
["fasdfasde"]["aaaccccddd"][][][][][][]

"fasdfasdefasdfhjasdkilfjasdklfjasdklfjasdklfjasdklfjklasdfjkl"

// 해쉬해야할 크기가 커지면 커질수

//    [루트]
//  []     []
// [][]


// 0 "fasdfasde"
// 0 "fasdfasdefasdfhjasdkilfjasdklfjasdklfjasdklfjasdklfjklasdfjkl"
// 자료구조로 사용할때 문제가 생깁니다.
// 자료구조로 사용할때 대부분을 index로 만들기 때문에
// 0~10까지 나오게 제한합니다.
// 겹치겠죠.
// 겹치는걸 해결하는 방법은 보통 체이닝
list로 만들거나 map으로 만듭니다.
[0][1][][][][][][]
[0]
[0]
[0]

// 해쉬의 충돌이랑
// 해쉬코드를 다른 의미로 쓸때가 있습니다.
// 그냥 순수하게 한번 공식만 돌렸을때는 기본적으로 거의 겹치지 않아요.
// 그럼 유일무이한 키가 되어 줍니다.
// 어느 컴퓨터에서 하건 똑같아 집니다.
// 클라이언트에 있는 어떤 몬스터는 곧 
// => 서버에 있는 어떤 몬스터라고 생각할수 있게 됩니다.
// 둘은 같은 해쉬코드를 가지고 있으니까.
// 서버의 8바이트짜리 
// 서버에서 몬스터를 만들면 몬스터에게 해쉬키8바이트(312312312)짜리 키를 주고
// 클라이언트의 어떤놈이 그 8바이트(312312312)의 키다.
// 서버에서 그 몬스터가 움직입니다.
// 클라야 (312312312)움직였어
// 서버가 잠깐 장애가 있다가 부활할거면
// 웹게임

// 서버가 꺼진다? 모든애들 다 드랍.
// 주소값도? 그자체로 유일무이한 키 이건 진짜 안겹칩니다.
// 서버가 잠깐 꺼질
// 1분안에 복구되었다고 칩시다.
// 30초???? 어 뭐지???
// 어떻게 됐죠? 서버에 있는 